Title: Fast modular cube root in Python CuPyDate: 2025-01-19 19:10Category: Math, PythonSummary: Finding cube roots mod $p$ using Tonelli Shanks Algorithm.Authors: Amir# Finding cube roots using Tonelli Shanks Algorithm.The modular cube root asks for the solution or solutions $x$ to the following equation:$$    x^3 \equiv A \quad (\mathrm{mod} \, p)$$One way of solving this congruence could be testing every $1 \leq x < p$. Unfortunately, this is very inefficient for large $p$ as this takes _$\mathcal{O}(p)$_ operations. Fortunately, there do exist efficient algorithms to find the modular cube root. One if them is an adapted version of the Tonelli Shanks Algorithm to cube roots discussed in [Nishihara et al](https://eprint.iacr.org/2009/457.pdf), which they cite as having a worst time complexity of _$\mathcal{O}((\log p)^4)$_.# Some examples.In the first two cases $p = 2$ or $p = 3$: The solutions are trivial and we have $A^3 \equiv A$, so there is always one solution. In case $p=11$ there also always exists exactly one cube root for every $A$.```p = 11|  A  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  10  ||  x  | {0} | {1} | {7} | {9} | {5} | {3} | {8} | {6} | {2} | {4} | {10} |```However, there is also prime moduli where the solutions are scattered around. For this, lets look at the case $p=13$ next. Here, we see that every number $A\neq0$ has either zero or three cube roots:```p = 13|  A  |  0  |    1    |  2 |  3 |  4 |     5    |  6 |  7 |    8    |  9 | 10 | 11 |    12     ||  x  | {0} | {1,3,9} | {} | {} | {} | {8,11,7} | {} | {} | {2,5,6} | {} | {} | {} | {10,4,12} |```When calculating cube roots modulo a prime $p>3$ for $A\neq 0$, it turns out there is always one solution when $p \, \mathrm{mod} \, 3 \equiv 2$ and either zero or exactly three solutions when $p \, \mathrm{mod} \, 3 \equiv 1$ as cited [here](https://math.stackexchange.com/questions/673418/cube-roots-modulo-p).For curiosity sake, we can also try a composite modulus, for example $q = 16$ and test all cases. Here, there exist 0, 1 or even 4 solutions! As far as I know, there is no efficient algorithm for finding these for composite moduli.```p = 16|  A  |      0     |  1  |  2 |   3  |  4 |   5  |  6 |  7  |      8      |  9  | 10 | 11  | 12 | 13  | 14 |  15  ||  x  | {0,8,4,12} | {1} | {} | {11} | {} | {13} | {} | {7} | {2,10,6,14} | {9} | {} | {3} | {} | {5} | {} | {15} |```In order to get an efficient implementation for prime moduli $p$, Ive rewritten the code as a Cuda kernel from the [Python2 implementation of Rolandb](https://stackoverflow.com/questions/6752374/cube-root-modulo-p-how-do-i-do-this) on Stackoverflow, because I wanted to explicitly speed up calculations on numpy/cupy arrays. The code is attached below and uses the int64 = long long number type.    #!python        '''    tonelli shanks modular cube root    adapted version for cuda kernel of :    cubic modular root code posted    by Rolandb on stackoverflow.  With new formatting.    https://stackoverflow.com/questions/6752374/cube-root-modulo-p-how-do-i-do-this    '''    ts_cubic_modular_roots = cp.ElementwiseKernel(        '''            int64 A, int64 p        ''',        '''            int64 x1, int64 x2, int64 x3        ''',        '''        long long a = A;        auto mod_exp = [](long long base, long long exp, long long mod) {            long long rem = base % mod;            for (long long i = 1; i < exp; i++){                rem = (rem*base) % mod;            }            return rem;        };        auto onemod = [&](long long p, long long r) {            long long t = p - 2;            while (mod_exp(t, (p - 1) / r, p) == 1) {                t -= 1;            }            return mod_exp(t, (p - 1) / r, p);        };        auto sol = [&](long long p, long long root, long long &x1, long long &x2, long long &x3) {            long long g = onemod(p, 3);            x1 = root % p;            x2 = (root * g) % p;            x3 = (root * mod_exp(g, 2, p)) % p;        };        auto tonelli3 = [&](long long a, long long p, long long &x1, long long &x2, long long &x3) {            a = a % p;            if (p == 2 || p == 3 || a == 0) {                x1 = a; x2 = 0; x3 = 0;            }            else if (p % 3 == 2) {                x1 = mod_exp(a, ((2 * p) - 1) / 3, p);                x2 = 0; x3 = 0;            }            else if (mod_exp(a, (p - 1) / 3, p) > 1) {                x1 = x2 = x3 = 0;            }            else {                long long s = 0, t = p - 1;                while (t % 3 == 0) {                    s++;                    t /= 3;                }                long long b = p - 2;                while (mod_exp(b, (p - 1) / 3, p) == 1) {                    b -= 1;                }                long long c = mod_exp(b, t, p);                long long r = mod_exp(a, t, p);                long long c1 = mod_exp(c, mod_exp(3, s - 1, p), p);                long long h = 1;                c = mod_exp(c, p - 2, p);                for (long long i = 1; i < s; i++) {                    long long d = mod_exp(r, mod_exp(3, s - i - 1, p), p);                    if (d == c1) {                        h = (h * c) % p;                        r = (r * mod_exp(c, 3, p)) % p;                    } else if (d != 1) {                        h = (h * mod_exp(c, 2, p)) % p;                        r = (r * mod_exp(c, 6, p)) % p;                    }                    c = mod_exp(c, 3, p);                }                long long k = ((t - 1) % 3 == 0) ? (t - 1) / 3 : (t + 1) / 3;                r = (mod_exp(a, k, p) * h) % p;                if ((t - 1) % 3 == 0) {                    r = mod_exp(r, p - 2, p);                }                if (mod_exp(r, 3, p) == a) {                    sol(p, r, x1, x2, x3);                } else {                    x1 = x2 = x3 = 0;                }            }        };        a = a % p;        if (p == 2 || p == 3 || a == 0) {            x1 = a; x2 = 0; x3 = 0;        }        else if (p % 3 == 2) {            x1 = mod_exp(a, ((2 * p) - 1) / 3, p);            x2 = 0; x3 = 0;        }        else if (mod_exp(a, (p - 1) / 3, p) > 1) {            x1 = x2 = x3 = 0;        }        else if (p % 9 == 4) {            long long root = mod_exp(a, ((2 * p) + 1) / 9, p);            if (mod_exp(root, 3, p) == a) {                sol(p, root, x1, x2, x3);            } else {                x1 = x2 = x3 = 0;            }        }        else if (p % 9 == 7) {            long long root = mod_exp(a, (p + 2) / 9, p);            if (mod_exp(root, 3, p) == a) {                sol(p, root, x1, x2, x3);            } else {                x1 = x2 = x3 = 0;            }        }        else if (p % 27 == 10 || p % 27 == 19) {            tonelli3(a, p, x1, x2, x3);        }        else {            tonelli3(a, p, x1, x2, x3);        }    ''',    'ts_cubic_modular_roots')    In order to use it on cupy arrays ```A``` and ```p```, you can just call it like any other function:    #!python        x1,x2,x3 = ts_cubic_modular_roots(A,p)    Or use a scalar modulus like ```p = cp.int64(307)```, with an array ```A```.